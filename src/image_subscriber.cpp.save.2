#include "image_subscriber.hpp"
#include <iostream>
#include <vector>


ImageSubscriber::ImageSubscriber() : Node("image_subscriber") {
	int status = XFilter_image_Initialize(&this->ip_inst, "filter_image");
	if (status != XST_SUCCESS) {
		RCLCPP_ERROR(this->get_logger(), "Error: Could not initialize the IP core.");
		return;
	}
	else{
		std::cout << "Imge processor initiated\n";
	}

	RCLCPP_INFO(this->get_logger(), "Initializing ImageSubscriber node");

	RCLCPP_INFO(this->get_logger(), "Starting camera subscription");

	camera_subscription_ = this->create_subscription<sensor_msgs::msg::Image>(
				"/image_raw",
				10,
				std::bind(&ImageSubscriber::onImageMsg, this, std::placeholders::_1));

	publisher_ = this->create_publisher<sensor_msgs::msg::Image>("/processed_image", 10);
}

ImageSubscriber::~ImageSubscriber()
{
	RCLCPP_INFO(this->get_logger(), "Subscriber out");
}

void ImageSubscriber::filterImage(const uint8_t *rowAbove, const uint8_t *rowCenter, const uint8_t* rowBelow,  uint8_t* outputRow, int width)
{
	const float kernel[3][3] = {
        {1 / 16.0f, 2 / 16.0f, 1 / 16.0f},
        {2 / 16.0f, 4 / 16.0f, 2 / 16.0f},
        {1 / 16.0f, 2 / 16.0f, 1 / 16.0f}
    	};

    	for (int x = 1; x < width - 1; ++x) {
        	float pixelValue = 0.0f;

        	pixelValue += rowAbove[x - 1] * kernel[0][0];
        	pixelValue += rowAbove[x]     * kernel[0][1];
        	pixelValue += rowAbove[x + 1] * kernel[0][2];

        	pixelValue += rowCenter[x - 1] * kernel[1][0];
        	pixelValue += rowCenter[x]     * kernel[1][1];
        	pixelValue += rowCenter[x + 1] * kernel[1][2];

        	pixelValue += rowBelow[x - 1] * kernel[2][0];
        	pixelValue += rowBelow[x]     * kernel[2][1];
        	pixelValue += rowBelow[x + 1] * kernel[2][2];

        	outputRow[x] = static_cast<uint8_t>(std::min(std::max(static_cast<int>(pixelValue), 0), 255));
   	 }

   	outputRow[0] = 0;
    	outputRow[width - 1] = 0;
}

cv::Mat ImageSubscriber::applyConvolutionToImage(cv::Mat& inputImage) {

    cv::Mat outputImage(120, 120, CV_8UC1);

    for (int y = 1; y < 120 - 1; ++y) {
	auto data = vec.data();

        auto rowAbove = inputImage.ptr<unsigned int >(y - 1)[0];

	auto rowCenter = inputImage.ptr<unsigned int>(y)[0];

        auto rowBelow = inputImage.ptr<unsigned int>(y + 1)[0];
	vec3.push_back(rowBelow);

	XFilter_image_Write_rowAbove_Words(&this->ip_inst, 0, vec.data(), 120);
	XFilter_image_Write_rowCenter_Words(&this->ip_inst, 0, vec2.data(), 120);
	XFilter_image_Write_rowBelow_Words(&this->ip_inst, 0, vec3.data(), 120);

	XFilter_image_Start(&this->ip_inst);

	    // Wait for the IP core to finish
	while (!XFilter_image_IsDone(&this->ip_inst));

	XFilter_image_Read_outputRow_Words(&this->ip_inst, 0, data, 120);

	for(int i = 0; i < 120; i++){
		outputImage.at<unsigned char>(y,i) = data[i];
		std::cout << outputImage.at<uchar>(y,i) << " ";
	}
	std::cout << std::endl;
       // filterImage(rowAbove, rowCenter, rowBelow, outputRow, width);
    }

    return outputImage;
}


void ImageSubscriber::onImageMsg(const sensor_msgs::msg::Image::SharedPtr msg) {
	RCLCPP_INFO(this->get_logger(), "Received image!");

	cv_bridge::CvImagePtr cv_ptr = cv_bridge::toCvCopy(msg, "rgb8");
	cv::Mat img = cv_ptr->image;

	cv::cvtColor(img, img, cv::COLOR_RGB2GRAY);
	resize(img, img, cv::Size(120,120), cv::INTER_LINEAR);
	int rows = img.rows;
	int cols = img.cols;

	if(this->test == 0){
		test = 1;
		cv::Mat inputImage = cv::imread("/home/mp4d/ros2_ws/src/project-ROS2-pkg/src/tile_110.jpg", cv::IMREAD_GRAYSCALE);

		resize(inputImage, inputImage, cv::Size(120,120), cv::INTER_LINEAR);
		if (inputImage.empty()) {
       			 std::cerr << "Error: Could not load image." << std::endl;
        		return ;
    		}

    		cv::Mat outputImage = applyConvolutionToImage(inputImage);
    		cv::imwrite("/home/mp4d/ros2_ws/src/project-ROS2-pkg/src/tile_110_new.jpg", outputImage);
	}

	std::cout << ">> APPLYING CONVOLUTION" << std::endl;
	img = applyConvolutionToImage(img);

 	std::cout << "Image rows = " << rows << ",  Image cols = " << cols  << std::endl;
	RCLCPP_INFO(this->get_logger(), "Successfully loaded image!");

	RCLCPP_INFO(this->get_logger(), "Publishing to topic!");
	sensor_msgs::msg::Image::SharedPtr img_msg = cv_bridge::CvImage(std_msgs::msg::Header(), "mono8", img).toImageMsg();
	publisher_->publish(*img_msg.get());
}

int main(int argc, char *argv[])
{
	setvbuf(stdout,NULL,_IONBF,BUFSIZ);

	rclcpp::init(argc,argv);
	rclcpp::spin(std::make_shared<ImageSubscriber>());

	rclcpp::shutdown();
	return 0;
}
